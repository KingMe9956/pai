Copyright (c) KingMe9956 All Rights Reserved 2025

// SPDX-License-Identifier: Proprietary
// Â© 2025 KingMe9956 | All Rights Reserved
// License: KingMe9956 Commercial License. See LICENSE in repo root.

/**
 * @title CustomWorkflow
 * @dev Extensible multi-step workflow contract for on-chain process automation, configurable in every direction.
 * This template is intended for secure, auditable business or DAO flows, onboarding, DeFi approvals, or compliance.
 * Each workflow step can hold state, emit events, and offer role-based branching.
 */
pragma solidity ^0.8.21;

contract CustomWorkflow {
    address public immutable owner;
    uint256 public workflowId;
    enum Step { Unstarted, Step1, Step2, Step3, Step4, Step5, Finished }

    mapping(address => Step) public userStep;
    mapping(address => string[5]) public userSelections; // Tracks user option choices per step

    event StepStarted(address indexed user, uint indexed step, string option);
    event StepCompleted(address indexed user, uint indexed step, string option);

    modifier onlyOwner() {
        require(msg.sender == owner, "Not contract owner");
        _;
    }

    constructor(uint256 _workflowId) {
        owner = msg.sender;
        workflowId = _workflowId;
    }

    // Customizable step actions
    function startWorkflow(string calldata option1) public {
        require(userStep[msg.sender] == Step.Unstarted, "Already started");
        userStep[msg.sender] = Step.Step1;
        userSelections[msg.sender][0] = option1;
        emit StepStarted(msg.sender, 1, option1);
    }

    function advanceStep2(string calldata option2) public {
        require(userStep[msg.sender] == Step.Step1, "Step1 not completed");
        userStep[msg.sender] = Step.Step2;
        userSelections[msg.sender][1] = option2;
        emit StepCompleted(msg.sender, 1, userSelections[msg.sender][0]);
        emit StepStarted(msg.sender, 2, option2);
    }

    function advanceStep3(string calldata option3) public {
        require(userStep[msg.sender] == Step.Step2, "Step2 not completed");
        userStep[msg.sender] = Step.Step3;
        userSelections[msg.sender][2] = option3;
        emit StepCompleted(msg.sender, 2, userSelections[msg.sender][1]);
        emit StepStarted(msg.sender, 3, option3);
    }

    function advanceStep4(string calldata option4) public {
        require(userStep[msg.sender] == Step.Step3, "Step3 not completed");
        userStep[msg.sender] = Step.Step4;
        userSelections[msg.sender][3] = option4;